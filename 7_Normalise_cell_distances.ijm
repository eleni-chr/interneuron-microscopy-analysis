/* STEP 7: NORMALISE CELL DISTANCES TO GRAY MATTER SIZE

Code written by Dr Eleni Christoforidou.

This ImageJ macro processes images of spinal cord cross-sections stored in a main folder containing multiple subfolders.
Each first-level subfolder contains inner subfolders, where each inner subfolder corresponds to one cross-section imaged over 4 colour channels (each representing a different antibody staining).
E.g.,
MainFolder
	Subfolder1
		InnerSubfolder1
		InnerSubfolder2
		...
	Subfolder2
		InnerSubfolder1
		...
		
This macro computes the Distance Transform for each channel and normalises cell distances to gray matter size.

This macro assumes that each inner subfolder contains:
  - A gray matter ROI file (name ending in "_gray_matter.zip") generated by the first macro
  - Channel images named "ch00_MAX.tif", "ch01_MAX.tif", etc.
  - One or more cell distribution CSV files with names ending in "_distances_angles.csv"
For each CSV, the macro uses the gray‐matter ROI itself to generate a distance transform,
then samples the distance value at each cell's coordinate and normalises it.
*/

mainDir = getDirectory("Choose the folder containing your cross-section subfolders");

// Loop first‐level subfolders
firstLevelFolders = getFileList(mainDir);
for (i = 0; i < firstLevelFolders.length; i++) {
    if (!File.isDirectory(mainDir + firstLevelFolders[i])) continue;
    firstLevelDir = mainDir + firstLevelFolders[i] + File.separator;

    // Loop inner subfolders
    innerFolders = getFileList(firstLevelDir);
    for (j = 0; j < innerFolders.length; j++) {
        if (!File.isDirectory(firstLevelDir + innerFolders[j])) continue;
        innerDir = firstLevelDir + innerFolders[j] + File.separator;
        print("Processing inner subfolder: " + innerFolders[j]);

        // Find Gray Matter ROI
        files = getFileList(innerDir);
        roiFound = false;
        for (k = 0; k < files.length; k++) {
            if (endsWith(files[k], "_gray_matter.zip")) {
                roiFile = innerDir + files[k];
                roiFound = true;
                break;
            }
        }
        if (!roiFound) {
            print("Gray matter ROI not found; skipping.");
            continue;
        }

        // Process each distances_angles CSV
        for (k = 0; k < files.length; k++) {
            if (!endsWith(files[k], "_MAX_distances_angles.csv")) continue;
            csvFile   = files[k];
            channelID = replace(csvFile, "_distances_angles.csv", "");
            template  = innerDir + channelID + ".tif";
            if (!File.exists(template)) {
                print("Missing image: " + channelID + ".tif; skipping " + csvFile);
                continue;
            }

            // 1. Determine image size
            open(template);
            w = getWidth();
            h = getHeight();
            close();

            // 2. Create blank ROI mask image
            newImage("gm_mask", "8-bit black", w, h, 1);

            // 3. Fill ROI region white
            roiManager("reset");
            roiManager("Open", roiFile);
            roiManager("Select", 0);
            selectWindow("gm_mask");
            run("Fill");
            
            // --- NEW BINARISATION STEPS ---
            // threshold everything >0 to 255, then convert to a clean mask
            setThreshold(1, 255);
            run("Convert to Mask");
            // --------------------------------
            
            // 4. Compute Distance Transform on that ROI mask
            run("Distance Map");
            dtName = channelID + "_Distance_Transform.tif";
            dtPath = innerDir + dtName;
            rename(dtName);
            saveAs("Tiff", dtPath);
            print("Saved DT: " + dtName);

            // 5. Get max for normalization
            getStatistics(area, mean, min, maxVal, std);
            if (maxVal == 0) {
                print("DT max=0; skipping CSV processing.");
                close();          // close DT
                roiManager("reset");
                continue;
            }
            print("Max DT: " + maxVal);

            // 6. Read and process CSV
            csvPath = innerDir + csvFile;
            csvText = File.openAsString(csvPath);
            lines   = split(csvText, "\n");
            if (lines.length < 2) {
                print("Empty CSV; skipping.");
                close();
                roiManager("reset");
                continue;
            }
            newCSV = lines[0] + ",DT_distance,Normalised_DT_distance\n";
            for (m = 1; m < lines.length; m++) {
                line = trim(lines[m]);
                if (line == "") continue;
                fields = split(line, ",");
                cellX = parseFloat(fields[1]);
                cellY = parseFloat(fields[2]);
                dtVal = getPixel(round(cellX), round(cellY));
                norm = 1.0 - (dtVal / maxVal);  // Cells right on the ROI boundary (dtVal = 0) become norm = 1.0; Cells at the very center (dtVal = maxVal) become norm = 0.0
                newCSV += line + "," + dtVal + "," + norm + "\n";
            }
            // 7. Save new CSV
            newCSVName = replace(csvFile, "_distances_angles.csv", "_DT.csv");
            File.saveString(newCSV, innerDir + newCSVName);
            print("Wrote: " + newCSVName);

            // Clean up
            close();          // close DT
            roiManager("reset");
        }
    }
}
print("Distance transform normalisation completed.");
